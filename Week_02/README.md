# week2-学习笔记


### 哈希表(Hash Table):
 
  散列表表,是更据关键码值(ke value) 而直接进行访问的数据结构,它通过把关键码值映射到表中一个位置来访问记录,以加快查找的速度
这个映射的函数叫做散列函数(Hash Function),存放记录的数组叫做哈希表(或散列表)
 	
####  工程中用到的比较多的	
- 用户信息表 			
- 缓存(LRU cache) 	
- 键值对存储(Redis)		


> 通过哈希函数 将对应的数据存在一个下标中,一般通过mo 的方式存储索引位置,但是也会存在碰撞的情况,就是同一个索引存了多条数据,如果哈希函数选用的好,会减少这种情况
如果同一个索引位置存在多个值,比较好也比较实用的方法是升维,拉出一个链表(拉链式解决冲突法),通常哈希的时间复杂度为O1,但是如果存在链表,链表很长也会增加时间复杂度,退化为O(n) 的级别



 #### 树 二叉树 二叉搜索树
    树由:根节点+左子树+右子树 构成
    树:特殊的链表, 树是特殊的图, 树和图最关键的是看有没有环
    完全二叉树: 他的根和每一级都是满的除了最底层的叶子节点可以不饱和

### 二叉树:
 子节点只有两个 
### 二叉搜索树
二叉搜索树,也称二叉排序树,有序二叉树(Ordered Binary Tree),排序二叉树(Sort Binary Tree), 是指一课空树或者具有下列性质的二叉树
 1. 左子树上所有节点的值均小于它的根节点的值
 2. 右子树上所有节点的值均大于它的根节点的值
 3. 以此类推:左,右子树也分别为二叉查找树(这就是重复性)
中序遍历是 升序排列



### 树的遍历
遍历树推荐递归,因为树的定义本身的话没有办法进行有效的循环,虽然可以采用广度优先的遍历,但是循环是很麻烦的,而树的递归的话很简单

 方法:
 - 前序遍历 :根左右
 - 中序遍历 :左根右
 - 后续遍历 :左右根



## 堆,二叉堆:
 堆是一种抽象的高级的数据结构,heap:可以迅速找到一堆数中的最大或者最小值的数据结构
 将根节点最大的堆叫做大顶堆或者大根堆,根节点最小的堆叫做小顶堆或小根堆.常见的堆有二叉堆,斐波拉契堆(也是基于树的)等
 
 ### 大顶堆
   -  find-max : O(1)
- delete-max:  O(log N)
- insrt(create):O(logN) or O(1)

一般来说是二叉堆,工业上是斐波拉契堆 (严格)时间和空间复杂度更好,它基于树不是二叉树而是多叉树
二叉堆比较容易实现但是它的时间效率并不是最好的

### 二叉堆的性质
  通过完全二叉树来实现(注意:不是二叉搜索树)
  1. 一颗完全树
  2. 树中任意节点的值总是>=其子节点的值

二叉搜索树也可以作为堆但是复杂度会升为log(n)

### 二叉堆的实现细节
 1. 二叉堆一般都是通过"数组"来实现
 2. 设"第一个元素"在数组中的索引为0 的话,则父节点和子节点的位置关系如下:
- 索引为左孩子的索引是(2*i+1)
- 索引为i的右孩子的索引是(2*i+2)
- 索引为的父节点的索引是floor((i-1)/2)

### 二叉堆的方法
    1. 堆的插入 (向上调整) 
    因为堆的特性(根大于子节点) 所以和根的值比较 如果大于它的父亲则交换位置,直到找到合适的位置
    - 新元素一律先插入到堆的尾部(最低)
    - 依次向上调整整个堆的结构(一直到根即可)	
     heapifyUp

    2. 堆的删除
    删除最大元素的话,将堆尾的元素替换到顶部元素去
    - 将堆尾元素替换到顶部 (即对顶被替代删除掉)
    - 依次从根部向下调整整个堆的结构(一直到堆尾即可)
     heapifyDown
二叉堆是堆(优先队列 priority_queue) 的一种常见且简单的实现,但是并不是最优的实现,二叉堆并不实用,工程中直接用优先队列就可以解决

## 图:

图比较少见,定义是有点有边就行
  数学中的定义: 
    定义一个Graph(v,E)
    
    v-vertex:点
    1. 度-入度和出度 (度:点连了多少个边,变的有向通过点的个数表示入度和出度)
    2. 点与点之间:连通与否
    E-edge:边 
    1:有向和无向(单行线,双向)
    2:权重(边长)

### 分类
    - 无向无权  
      边无方向无长度 (邻接矩阵  为对称)
    - 有向无权  
      边有方向无长度 (邻接矩阵  不对称)
    - 无向有权
      边有方向无长度 (对称,但是边是有权重的)
    - 有向有权 
      边有方向有长度 

### 常见的数据结构
1. 邻接矩阵 
2. 邻接表

均为二维数据结构
  
  - 一维:每一行的标识,指的是点的下标
  - 二维(列): 
    - 邻接矩阵 :中指的是也是点, 一维中行代表的点和列中代表的点,它们之间的边是多少,如果两点之间的边有权重就是权重值如果无权重就是0/1, 0:无直接边相连 1:有直接边相连
    - 邻接表:一维数组拉出的链表,后面直接写的边.如: 0->1->3  : 表示由0点连着1和3这两个点




  ## 个人总结
   这周里的数据结构中堆的理解不够,哈希算法用的不好,需要后期多练习,高级的数据结构还是比较抽象的,需要多多练习
   