
# week1-学习笔记
### 时间复杂度:

常用Big O notation 来进行表示
 	
####  最常见的时间复杂度	
- O(1):常数复杂度 			Constant Complexity 
- O(logn): 对数复杂度  		Logarithmic Complexity
- O(n) :线性时间复杂度 		 Liner Complexity 
- O(n^2):平方                 		N square Complexity 
- O(n^3):立方				N cubic Complexity 
- O(2^n):指数				Exponential Growth 
- O(n!):Factorial 阶乘


 #### 分析时间复杂度

    最常用的方式就是直接看这个函数,或者这段代码,根据 n 的不同情况会运行多少次
    O(1): 复杂度可以不需要前面的系数


### 空间复杂度:
 个人理解大概意思为占用内存的多少 (欢迎指正)




## 链表:

1 .分为单向链表,双向链表,和循环链表

    链表的组成
    1. 内部的元素有多个node 组成,,每个node内部含有value (一些我们的代码),和next 指针,通过next 的指向链接形成node 链条
    2. 如果存在prev 指针为多向链表,同时单向链表tail node 的next 会指向为 null 如果tail node 指向为head 为循环链表
    3. 链表的增加和删除通过改变next 指向,时间复杂度可以降低为 O(1) ,但是他的随机访问节点的时间复杂度为 o(n), 

优化链表的这个问题,出现了跳表
 跳表用于元素的有序情况对标的是二叉搜素树中的平衡树,和二分查找(也是作用于有序元素),是一种插入/删除/搜索 都是 o(logn)的数据结构
 它最大的优势就是原理简单,容易实现,方便扩展,效率更高,因此在一些热门的项目里用来替代平衡树,


  一般一维的数据结构要是想加速的话方法之一是升维


  ## 对与算法练习
    1.算法是有方法的,就算当时不理解看不明白也不要去死磕,多写多练,多去体会, (个人体会上比如 有些比较抽象的递归 当时看不出为什么要在这里递归,但是多写几遍之后会有些感觉明白的地方)
    2.双指针法,用来做 有效山脉,三数之和这种算法题会变的简单很多
    3.算法一定要多练,多看写的优秀并且简洁的代码 (针对个人的现阶段而言的,太精简晦涩难懂的实在看不懂)