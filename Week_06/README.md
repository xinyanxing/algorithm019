# week6-学习笔记

### 动态规划

#### 回顾
  -  分治+回溯+递归 这些较为复杂的数据结构,这些的本质就是将复杂的问题分解成各种小的子问题,同时寻找他的重复性
  - 不管是分治,回溯,递归,还是动态规划,它们并没有本质上的非常大的不一样

> 递归和分治代码模板不同的地方在于分治在处理当前层逻辑时需要
>- 拆分子问题
>- 每个子问题调用递归函数,也就是每个子问题都要dill down (下探)
>- 处理完了之后将每个子问题的结果储存起来--也就是处理合并所有子结果集
>- 最后一步和递归一样(看状态是否需要初始化,恢复当前层状态)

#### 感触
 1. 人肉递归低效,很累
 2. 找到最近最简方法,将其拆解成可重复解决的问题
 3. 数学归纳法思维(抵制人肉递归的诱惑)

*本质:寻找重复性-->计算机指令集*



#### 动态规划是什么
    动态规划(dynamic progrramming),动态的递推,其实他本质上要解决的问题就是一个递归问题或者是分治问题,但是它和普通的递归分治稍微有点不一样: 它拥有分治+最优子结构
    - DP 和分治是有内在联系的他们并不是完全割裂的两个算法;
    - 一般来说动态规划的问题他会让你求一个最优解,或者是求一个最大值,或者求一个最少的方式这样,因为它有最优子结构的存在,所以你在中间的每一步的话就不需要把所有的状态都保存下来,你只需要存最优的状态,当然你还需要证明,如果我每一步都存在着相当于最优的值,最后的话我就能够推导出一个全局的最优的值,
        - 有缓存或者是说状态的存储数组
        - 在每一步可以把次优的状态给淘汰掉,只保留在这一步里面最优或者是较优的一些状态来推导存储最后的全局最优

#### 动态规划关键点
//opt => optimal 
 1. 最优子结构 opt[n]=best_of(opt[n-1],opt[n-2,...])

 2. 储存中间状态:opt[i]
 3. 递推公式(美其名曰:状态转移方程或者DF方程)
> fib: opt[i]=opt[n-1]+opt[n-2]
> 二维路径:opt[i,j]=opt[i,j+1]+opt[i+1,j] (且判断a[i,j]是否是空地)



#### 动态规划
1. 打破自己的思维习惯,形成机器思维
2.理解复杂逻辑关键


### 总结
    - 动态规划和递归或者分治没有根本上的区别(关键看有无最优的子结构)
    > 如果没有最优子结构说明所有的子问题你都需要计算一遍,同时把最后的结果给合并到一起,所以传统意义上称之为分治
    > 如果非要叫动态规划,也可以,可以理解为每次的最优解就是当前解就行了,它没有所谓的每次比较和淘汰对的一个过程,但一般传统意义上我们就称之为分治
    - 共性:找到重复子问题
    - 差异性: 最优子结构,中途可以淘汰次优解 
    > 必须淘汰次优解,否则的话如果你把次优解都保存下来的话,你会发现你要做的事情的复杂度就会比淘汰次优解来的更多了 ,因为动态规划会淘汰次优解,所以更多时候复杂度是更低的 或者是更有效的 (如果是傻递归或者是傻分治的话通常情况下时间复杂度是指数级的)


    
